import locations.Location;
import roads.Road;

import java.time.Period;
import java.util.*;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * This class represents a map with locations and roads between locations. the locations nad roads can be added by methods.
 * The problem for which this class was created is to find the route between two valid locations through the roads.
 */
public class RouteProblem {
    private List<Location> locations;
    private List<Road> roads;

    /**
     * The constructor of RouteProblem class, which initialize the  empty list of roads and locations
     */
    RouteProblem(){
        locations= new ArrayList<>();
        roads = new ArrayList<>();
    }


    /**
     * The second constructor of RouteProblem class
     * @param locations the list of locations received as a parameter
     * @param roads the list of roads received as a parameter
     */
    RouteProblem(List<Location> locations,List<Road> roads){
        this.locations= locations;
        this.roads = roads;
    }


    /**
     * Method for adding the a location in locations list
     * @param location must not be in the existing list of locations
     */
    public void addLocation(Location location){
        if(!locations.contains(location)) locations.add(location);
    }

    /**
     * Method for adding the a road in roads list
     * @param road must not be in the existing list of roads
     */
    public void addRoad(Road road){
        if(!roads.contains(road)&&locations.contains(road.getLocation1())&&locations.contains(road.getLocation2())) roads.add(road);
    }


    /**
     * getBestRoute function determine the best route from start location to end location using the Dijkstra algorithm.
     * @param startLocation must by in locations list. It has the meaning of current/start location.
     * @param endLocation must by in locations list. The function determine if there is a road to endLocation.
     * @return return true if exists a path between these 2 locations and false if does not exist.
     */
    public Map<Location,Location> getBestRoutes(Location startLocation, Location endLocation){
        Map<Location,Location> bestPrevious = new HashMap<>();
        if(!locations.contains(startLocation)||!locations.contains(endLocation)) return null  ;

        Map<Location,Double> distances = new HashMap<>();


        List<Location> visitedLocations = new ArrayList<>();
        PriorityQueue<Location> locationQueue = new PriorityQueue<>(
                (a, b) -> Double.compare(distances.get(a), distances.get(b))
        );

        locations.forEach(location -> distances.put(location,Double.MAX_VALUE));

        distances.put(startLocation,0.0);

        locationQueue.add(startLocation);

        while(!locationQueue.isEmpty()){
            Location currentLocation = locationQueue.poll();
            if(visitedLocations.contains(endLocation)){
                return bestPrevious;
            }
            visitedLocations.add(currentLocation);
            for(Road road :roads) {

                if (!visitedLocations.contains(road.getLocation1()) && road.getLocation2().equals(currentLocation)) {
                    if (distances.get(road.getLocation1()) > distances.get(currentLocation) + road.getLength()) {
                        bestPrevious.put(road.getLocation1(), currentLocation);
                        distances.replace(road.getLocation1(), distances.get(currentLocation) + road.getLength());
                        locationQueue.add(road.getLocation1());
                    }
                } else if (!visitedLocations.contains(road.getLocation2()) && road.getLocation1().equals(currentLocation)) {
                    if (distances.get(road.getLocation2()) > distances.get(currentLocation) + road.getLength()) {
                        bestPrevious.put(road.getLocation2(), currentLocation);
                        distances.replace(road.getLocation2(), distances.get(currentLocation) + road.getLength());
                        locationQueue.add(road.getLocation2());
                    }
                }
            }
        }

        return bestPrevious;

    }

    /**
     * This function return the exact route from end location to start location using the map which is returning from
     * getBestRoutes function. The stack is to store the exact path from the mapping with all efficient routes from one
     * node to another generated by the algorithm.
     * @return the reverser stack which is converting to list of locations.
     */
    public List<Location> findBestRoute(Location startLocation, Location endLocation){

        Map<Location,Location> bestRoutes = getBestRoutes(startLocation,endLocation);
        Stack<Location> locationStack = new Stack<>();
        locationStack.push(endLocation);
        while(locationStack.peek() != startLocation){
            locationStack.push(bestRoutes.get(locationStack.peek()));
        }
        Collections.reverse(locationStack);

        return Stream.of(locationStack.toArray()).map(object ->(Location) object).collect(Collectors.toList());
    }


}
